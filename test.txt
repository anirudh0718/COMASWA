#safe_d = np.zeros((2,))
            safe_d = np.array(Robots[i].ecbf.compute_safe(obs,Robots,i,2))

            safe_dxi[:,i] = safe_d.reshape(2,)




print('These are the starting postions of the robots',start)
print('These are goal position f the robots',goal)

exit()

print('This is robot {}s goal'.format(i),Robots[i].goal)


np.array([
    [0, Df_b,ddiag_rec,Df_l],
    [Df_b, 0, Df_l, 0],
    [ddiag_rec, Df_l, 0, Df_b],
    [Df_l, 0,Df_b, 0]
])


ddiag_rec =np.sqrt(np.power(Df_l,2) + np.power(Df_b,2))


xo = 2*sub[0]*(np.power(np.cos(t),2)/a**2+ np.power(np.sin(t),2)/b**2) + 2*sub[1]*(1/a**2 - 1/b**2)
    yo = 2*sub[1]*(np.power(np.sin(t),2)/a**2+np.power(np.cos(t),2)/b**2) + 2*sub[0]*(1/a**2 - 1/b**2)



# Compute hf for only greater than inequality

def compute_hf_g(state,Robots,n,r,L,weights,e):
    hf = np.zeros((len(topological_neighbors(L,n)), 1))
    idx = 0    
    gamma = 1
    #print(topological_neighbors(L,n)+1)
    for j in topological_neighbors(L,n):
        sub =  state['q'][:2].reshape(2,1) - Robots[j].state['q'][:2].reshape(2,1)
        xo = sub[0]
        yo = sub[1]
            
        
        if Use_TVCBF:

            x_j_dot = -xo*Robots[j].vel[0]
            y_j_dot = -yo*Robots[j].vel[1]
            
            hf[idx]= gamma*((np.power(xo,2)+ np.power(yo,2)) - np.power(weights[n,j] - e,2)) + x_j_dot + y_j_dot
        else:
            hf[idx]= gamma*((np.power(xo,2)+ np.power(yo,2)) - np.power(weights[n,j] - e,2))
        idx += 1

    #print('This is the formation greater h for robot 1',hf)
    return hf
# Compute hf for only lesser than inequality
def compute_hf_l(state,Robots,n,r,L,weights,e):
    hf = np.zeros((len(topological_neighbors(L,n)), 1))
    idx = 0
    for j in topological_neighbors(L,n):
        sub =  state['q'][:2].reshape(2,1) - Robots[j].state['q'][:2].reshape(2,1)
        xo = sub[0]
        yo = sub[1]
            #print(xo,yo)
        if Use_TVCBF:

            x_j_dot = -xo*Robots[j].vel[0]
            y_j_dot = -yo*Robots[j].vel[1]
            
            hf[idx]= (np.power(xo,2)+ np.power(yo,2)) - np.power(weights[n,j] - e,2) + x_j_dot + y_j_dot
        else:
            hf[idx]= (np.power(xo,2)+ np.power(yo,2)) - np.power(weights[n,j] - e,2)
        idx += 1

    return hf

    ----------------------------------------------------------------------------------------------

    # Compute hf for only greater than inequality

def compute_hf_g(state,Robots,n,r,L,weights,e):
    hf = np.zeros((len(topological_neighbors(L,n)), 1))
    idx = 0    
    #print(topological_neighbors(L,n)+1)
    for j in topological_neighbors(L,n):
        sub =  state['q'][:2].reshape(2,1) - Robots[j].state['q'][:2].reshape(2,1)
        xo = sub[0]
        yo = sub[1]
            
        hf[idx]= (np.power(xo,2)+ np.power(yo,2)) - np.power(weights[n,j] - e,2)
        idx += 1
    #print('This is the formation greater h for robot 1',hf)
    return hf
# Compute hf for only lesser than inequality
def compute_hf_l(state,Robots,n,r,L,weights,e):
    hf = np.zeros((len(topological_neighbors(L,n)), 1))
    idx = 0
    for j in topological_neighbors(L,n):
        sub =  state['q'][:2].reshape(2,1) - Robots[j].state['q'][:2].reshape(2,1)
        xo = sub[0]
        yo = sub[1]
            #print(xo,yo)
        hf[idx]= np.power(weights[n,j] + e,2) - (np.power(xo,2)+ np.power(yo,2))
        idx += 1

    return hf



def compute_A_far(self,obst):
            A = np.empty((0,2))

            #print('This is obst',obst[0,:])

            #print('This is the shape', obst.shape)
            #exit()

            for i in range(obst.shape[1]):
                
                sub = np.atleast_2d(self.state["q"][:2]).T - obst[i, :].T.reshape(2,1)
                xo = sub[0]
                yo = sub[1]

                atmp = np.array([np.hstack((xo, yo))])
                A =np.array(np.vstack((A,atmp)))
            return A

    def compute_h_far(self,obst):
        h = np.zeros((obst.shape[1], 1))
        for i in range(obst.shape[1]):
            sub = np.atleast_2d(self.state["q"][:2]).T - obst[i, :].T.reshape(2,1)
            xo = sub[0]
            yo = sub[1]
            h[i] = np.power(xo,2)+ np.power(yo,2)- np.power(Ds-e,2) 
        return h


    def compute_safe_f(self,obs,u):
        A = self.compute_A_far(obs)
        h = self.compute_h_far(obs)

        

        P = np.array([[2, 0],[0, 2]])
        G = -2*A
        """ print('This is u nom',self.compute_nom())
        exit() """
        q = -2*u
        #print('This is q',q)

        #print(A.shape,h.shape,P.shape,G.shape,q.shape)

        #exit()
        #self.h['h'].append(h)
        print(G,q)
        
        sol = solve_qp(P,q,G,h)

        u_st = sol['x']

        return u_st